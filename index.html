<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>小さな島デモ FPV版（r146）</title>
<style>
  html, body { height: 100%; margin: 0; background: #0b1220; color: #e9ecff; font-family: system-ui, -apple-system, Segoe UI, Arial, "Noto Sans JP", sans-serif; }
  #ui { position: fixed; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
  .hud { display: flex; gap: 8px; padding: 10px; pointer-events: none; }
  .chip { background: rgba(20,25,46,.75); border: 1px solid rgba(88,225,255,.25); border-radius: 999px; padding: 6px 12px; font-variant-numeric: tabular-nums; box-shadow: 0 6px 18px rgba(0,0,0,.35); }
  .hint { margin-left: auto; opacity: .85; }
  #stickArea { position: fixed; left: 12px; bottom: 12px; width: 160px; height: 160px; pointer-events: auto; border-radius: 12px; background: rgba(20,25,46,.25); border: 1px dashed rgba(88,225,255,.25); touch-action: none; }
  #stickBase, #stick { position: absolute; border-radius: 50%; transform: translate(-50%,-50%); touch-action: none; }
  #stickBase { width: 110px; height: 110px; left: 80px; top: 80px; background: rgba(88,225,255,.08); border: 1px solid rgba(88,225,255,.35); }
  #stick { width: 56px; height: 56px; left: 80px; top: 80px; background: rgba(88,225,255,.35); border: 2px solid rgba(255,255,255,.6); }
  #jumpBtn { position: fixed; right: 18px; bottom: 18px; width: 70px; height: 70px; border-radius: 50%; background: rgba(88,225,255,.28); border: 2px solid rgba(255,255,255,.6); pointer-events: auto; touch-action: none; }
  #credits { text-align: center; font-size: 12px; opacity: .75; padding: 6px 0 10px; }
  #error { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; text-align: center; padding: 20px; background: #0b1220; }
  #error .box { background: #1a2036; border: 1px solid #334; padding: 16px; border-radius: 10px; }
  canvas { display: block; }
</style>
</head>
<body>
<div id="ui">
  <div class="hud">
    <div class="chip">視点: <span id="viewModeLabel">三人称</span></div>
    <div class="chip hint">V:一/三人称切替（PC）／WASD移動（モバイル:左下スティック）</div>
  </div>
  <div class="hud" style="justify-content:center;">
    <div id="credits">小さな島デモFPV：歩き回ってコインを集めよう</div>
  </div>
</div>
<div id="stickArea"><div id="stickBase"></div><div id="stick"></div></div>
<div id="jumpBtn"></div>
<div id="error"><div class="box">WebGLを初期化できませんでした。別のブラウザ（Chrome/Edge）で開くか、再読み込みしてください。</div></div>

<!-- Three r146 + OrbitControls（非モジュール）/ フォールバック付き -->
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"
        onerror="this.onerror=null;this.src='https://unpkg.com/three@0.146.0/build/three.min.js'"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.min.js"
        onerror="this.onerror=null;this.src='https://unpkg.com/three@0.146.0/examples/js/controls/OrbitControls.min.js'"></script>

<!-- 画面上エラーバー（スマホでも原因特定しやすく） -->
<script>
(function(){
  function showErr(msg){
    const d=document.createElement('div');
    d.style.cssText='position:fixed;left:0;top:0;right:0;background:#200;color:#fff;padding:8px;z-index:9999;font:12px -apple-system,system-ui';
    d.textContent=msg; document.body.appendChild(d);
  }
  window.addEventListener('error',e=>showErr('Error: '+e.message));
  window.addEventListener('unhandledrejection',e=>showErr('Promise: '+(e.reason?.message||e.reason)));
  setTimeout(()=>{
    if(!window.THREE) return showErr('THREE failed to load');
    if(!THREE.OrbitControls && !window.OrbitControls) showErr('OrbitControls failed to load');
  }, 1000);
})();
</script>

<script>
(function () {
  if (!window.THREE || !document.createElement('canvas').getContext) {
    document.getElementById('error').style.display = 'flex';
    return;
  }

  // === Scene / Renderer / Camera / Controls ===
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x6ea8ff);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0, 30, 60);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.target.set(0, 10, 0);
  controls.maxPolarAngle = Math.PI * 0.49;

  // === First-person toggle ===
  let viewMode = 'third';                   // 'third' or 'first'
  const HEAD_HEIGHT = 1.6;
  let fpYaw = 0, fpPitch = 0;
  const FP_SENS = 0.0025;
  let pointerLocked = false;
  const viewLabel = document.getElementById('viewModeLabel');

  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase() === 'v') {
      if (viewMode === 'third') {
        viewMode = 'first';
        viewLabel.textContent = '一人称';
        controls.enabled = false;
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        fpYaw = Math.atan2(dir.x, dir.z);
        fpPitch = Math.asin(THREE.MathUtils.clamp(dir.y, -0.999, 0.999));
        renderer.domElement.requestPointerLock?.();
      } else {
        viewMode = 'third';
        viewLabel.textContent = '三人称';
        document.exitPointerLock?.();
        controls.enabled = true;
      }
    }
  });
  document.addEventListener('pointerlockchange', ()=>{
    pointerLocked = (document.pointerLockElement === renderer.domElement);
  });
  document.addEventListener('mousemove', (e)=>{
    if (viewMode === 'first' && pointerLocked) {
      fpYaw   -= e.movementX * FP_SENS;
      fpPitch -= e.movementY * FP_SENS;
      fpPitch = THREE.MathUtils.clamp(fpPitch, -Math.PI/2+0.1, Math.PI/2-0.1);
    }
  });

  // === Lights ===
  const sun = new THREE.DirectionalLight(0xffffff, 1.0);
  sun.position.set(80, 120, 40);
  scene.add(sun);
  scene.add(new THREE.AmbientLight(0xffffff, 0.35));

  // === Terrain ===
  const ISLAND_SIZE = 400;
  const HALF = ISLAND_SIZE / 2;

  function hash(x, z) { return (Math.sin(x * 12.9898 + z * 78.233) * 43758.5453) % 1; }
  function valueNoise(x, z) {
    const xi = Math.floor(x), zi = Math.floor(z);
    const xf = x - xi, zf = z - zi;
    const h00 = hash(xi,zi), h10 = hash(xi+1,zi), h01 = hash(xi,zi+1), h11 = hash(xi+1,zi+1);
    const u = xf*xf*(3-2*xf), v = zf*zf*(3-2*zf);
    return THREE.MathUtils.lerp(THREE.MathUtils.lerp(h00,h10,u), THREE.MathUtils.lerp(h01,h11,u), v);
  }
  function fbm(x,z) {
    let a=0, amp=1, freq=0.05;
    for (let i=0;i<4;i++) { a += valueNoise(x*freq, z*freq)*amp; amp*=0.5; freq*=2.0; }
    return a;
  }
  function islandHeight(x, z) {
    const r = Math.sqrt(x*x + z*z);
    const mask = Math.max(0, 1 - Math.pow(r / HALF, 2));
    const base = mask*mask;
    const noise = fbm(x, z);
    const h = base * 22 + (noise-0.6) * 6 * base;
    return h;
  }

  const segs = 200;
  const geo = new THREE.PlaneGeometry(ISLAND_SIZE, ISLAND_SIZE, segs, segs);
  geo.rotateX(-Math.PI/2);
  const pos = geo.attributes.position;
  for (let i=0; i<pos.count; i++) {
    const x = pos.getX(i);
    const z = pos.getZ(i);
    pos.setY(i, islandHeight(x, z));
  }
  pos.needsUpdate = true;
  geo.computeVertexNormals();

  const terrainMat = new THREE.MeshStandardMaterial({ color: 0x8fbf7f, roughness: 0.95, metalness: 0.0 });
  const terrain = new THREE.Mesh(geo, terrainMat);
  terrain.receiveShadow = true;
  scene.add(terrain);

  // Water
  const waterGeo = new THREE.CircleGeometry(HALF*1.15, 64);
  const waterMat = new THREE.MeshPhysicalMaterial({ color: 0x3aa9ff, roughness: 0.2, metalness: 0.0, transparent: true, opacity: 0.6 });
  const water = new THREE.Mesh(waterGeo, waterMat);
  water.rotation.x = -Math.PI/2;
  water.position.y = 0.0;
  scene.add(water);

  // Trees
  const trees = new THREE.Group();
  scene.add(trees);
  const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8a5a2b, roughness: 0.9 });
  const leafMat  = new THREE.MeshStandardMaterial({ color: 0x1f8a3b, roughness: 0.7 });
  function placeTrees(n) {
    n = n || 80;
    for (let i=0; i<n; i++) {
      const ang = Math.random()*Math.PI*2;
      const rad = Math.random()*HALF*0.8;
      const x = Math.cos(ang)*rad;
      const z = Math.sin(ang)*rad;
      const y = islandHeight(x,z);
      if (y < 2) { i--; continue; }
      const trunkH = THREE.MathUtils.randFloat(2.2, 3.2);
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, trunkH, 6), trunkMat);
      trunk.position.set(x, y + trunkH/2, z);
      const crownH = THREE.MathUtils.randFloat(2.8,3.6);
      const crownR = THREE.MathUtils.randFloat(1.2,1.7);
      const crown = new THREE.Mesh(new THREE.ConeGeometry(crownR, crownH, 8), leafMat);
      crown.position.set(x, y + trunkH + crownH*0.45, z);
      trees.add(trunk, crown);
    }
  }
  placeTrees();

  // Coins
  const coinMat = new THREE.MeshStandardMaterial({ color: 0xffd35a, metalness: 0.6, roughness: 0.2, emissive: 0x332200, emissiveIntensity: 0.25 });
  const coins = [];
  function placeCoins(n) {
    n = n || 18;
    for (let i=0;i<n;i++) {
      let x=0,z=0,y=0;
      for (let t=0;t<50;t++) {
        const ang = Math.random()*Math.PI*2;
        const rad = THREE.MathUtils.randFloat(HALF*0.15, HALF*0.75);
        x = Math.cos(ang)*rad;
        z = Math.sin(ang)*rad;
        y = islandHeight(x,z);
        if (y>3) break;
      }
      const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,0.12,24), coinMat);
      coin.rotation.x = Math.PI/2;
      coin.position.set(x, y+0.9, z);
      scene.add(coin);
      coins.push(coin);
    }
  }
  placeCoins(18);
  document.getElementById('credits').textContent += '（コイン: '+coins.length+'）';

  // === Player: low-poly human (white shirt + brown shorts) ===
  const player = new THREE.Group();
  const matSkin  = new THREE.MeshStandardMaterial({ color: 0xffd6b0, roughness: 0.7 });
  const matShirt = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
  const matPants = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.9 });
  const matShoes = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.6 });
  // body
  const torso = new THREE.Mesh(new THREE.BoxGeometry(1.4, 2.0, 0.8), matShirt);
  torso.position.y = 2.0; player.add(torso);
  // head
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), matSkin);
  head.position.y = 3.4; player.add(head);
  // arms
  const armGeo = new THREE.BoxGeometry(0.4, 1.6, 0.6);
  const armL = new THREE.Mesh(armGeo, matShirt); armL.position.set(-1.0, 2.0, 0);
  const armR = new THREE.Mesh(armGeo, matShirt); armR.position.set( 1.0, 2.0, 0);
  player.add(armL, armR);
  // legs
  const legGeo = new THREE.BoxGeometry(0.6, 1.2, 0.7);
  const legL = new THREE.Mesh(legGeo, matPants); legL.position.set(-0.4, 0.7, 0);
  const legR = new THREE.Mesh(legGeo, matPants); legR.position.set( 0.4, 0.7, 0);
  player.add(legL, legR);
  // shoes
  const shoeGeo = new THREE.BoxGeometry(0.7, 0.25, 1.0);
  const shoeL = new THREE.Mesh(shoeGeo, matShoes); shoeL.position.set(-0.4, 0.1, 0.2);
  const shoeR = new THREE.Mesh(shoeGeo, matShoes); shoeR.position.set( 0.4, 0.1, 0.2);
  player.add(shoeL, shoeR);

  player.position.set(0, islandHeight(0,0)+0.05, 0);
  scene.add(player);

  // camera & controls target
  controls.target.copy(player.position);
  camera.position.set(player.position.x+10, player.position.y+12, player.position.z+18);

  // Movement
  const keys = { w:0,a:0,s:0,d:0 };
  let vel = new THREE.Vector3();
  let onGround = false;
  function getGroundY(x,z){ return islandHeight(x,z); }

  // mobile joystick
  const stickArea = document.getElementById('stickArea');
  const stick = document.getElementById('stick');
  let joyActive = false, joyDir = {x:0, y:0};
  function setStick(x, y) { stick.style.left = x+'px'; stick.style.top = y+'px'; }
  function clampVec(v, max){ const l = Math.hypot(v.x, v.y); if (l>max){ v.x*=max/l; v.y*=max/l;} }
  stickArea.addEventListener('pointerdown', (e)=> {
    joyActive = true; stickArea.setPointerCapture(e.pointerId);
    const rect = stickArea.getBoundingClientRect(); const cx = e.clientX-rect.left, cy = e.clientY-rect.top;
    setStick(cx, cy);
    const v = {x: cx-80, y: cy-80}; clampVec(v, 50); joyDir.x = v.x/50; joyDir.y = v.y/50;
  });
  stickArea.addEventListener('pointermove', (e)=> {
    if (!joyActive) return;
    const rect = stickArea.getBoundingClientRect(); const cx = e.clientX-rect.left, cy = e.clientY-rect.top;
    const v = {x: cx-80, y: cy-80}; clampVec(v, 50); setStick(80+v.x, 80+v.y);
    joyDir.x = v.x/50; joyDir.y = v.y/50;
  });
  stickArea.addEventListener('pointerup', ()=> { joyActive=false; setStick(80,80); joyDir.x=0; joyDir.y=0; });

  const jumpBtn = document.getElementById('jumpBtn');
  let jumpQueued = false;
  jumpBtn.addEventListener('pointerdown', ()=> { jumpQueued = true; setTimeout(()=>jumpQueued=false, 180); });

  window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    if (e.key==='w' || e.key==='ArrowUp') keys.w=1;
    if (e.key==='a' || e.key==='ArrowLeft') keys.a=1;
    if (e.key==='s' || e.key==='ArrowDown') keys.s=1;
    if (e.key==='d' || e.key==='ArrowRight') keys.d=1;
    if (e.key===' ' && onGround) vel.y = 9;
  });
  window.addEventListener('keyup', (e) => {
    if (e.key==='w' || e.key==='ArrowUp') keys.w=0;
    if (e.key==='a' || e.key==='ArrowLeft') keys.a=0;
    if (e.key==='s' || e.key==='ArrowDown') keys.s=0;
    if (e.key==='d' || e.key==='ArrowRight') keys.d=0;
  });

  function updatePlayer(dt) {
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0; forward.normalize();
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).negate();

    const input = new THREE.Vector3((keys.d - keys.a) + joyDir.x, 0, (keys.s - keys.w) + joyDir.y);
    if (input.lengthSq()>1e-6) input.normalize();

    const move = new THREE.Vector3();
    move.addScaledVector(forward, -input.z);
    move.addScaledVector(right, input.x);

    const speed = 10;
    vel.x = THREE.MathUtils.damp(vel.x, move.x*speed, 8, dt);
    vel.z = THREE.MathUtils.damp(vel.z, move.z*speed, 8, dt);

    const groundY = getGroundY(player.position.x, player.position.z) + 0.8;
    const gravity = -25;
    if (player.position.y <= groundY + 0.01) {
      player.position.y = groundY;
      vel.y = 0;
      onGround = true;
    } else {
      vel.y += gravity * dt;
      onGround = false;
    }

    if (jumpQueued && onGround) { vel.y = 9; jumpQueued = false; }

    player.position.addScaledVector(vel, dt);

    const r = Math.hypot(player.position.x, player.position.z);
    const maxR = HALF*1.1;
    if (r > maxR) {
      const s = maxR / r;
      player.position.x *= s;
      player.position.z *= s;
    }
  }

  // 歩行アニメ＆向き
  let walkPhase = 0;
  let lastPlayer = player.position.clone();
  function updateHumanAnim(dt){
    const speed = new THREE.Vector3().subVectors(player.position, lastPlayer).length() / Math.max(dt,1e-6);
    const s = Math.min(1, speed/6);
    walkPhase += dt * 8 * s;
    const a = Math.sin(walkPhase)*0.6*s;
    const b = Math.cos(walkPhase)*0.6*s;
    const armL = player.children[2], armR = player.children[3], legL = player.children[4], legR = player.children[5];
    armL.rotation.x =  a;  armR.rotation.x = -a;
    legL.rotation.x = -b;  legR.rotation.x =  b;
    const dir = new THREE.Vector3().subVectors(player.position, lastPlayer); dir.y = 0;
    if (dir.lengthSq() > 1e-5) player.rotation.y = Math.atan2(dir.x, dir.z);
    lastPlayer.copy(player.position);
  }

  // 昼夜っぽい
  function updateLighting(t) {
    const tod = (Math.sin(t*0.02)*0.5 + 0.5);
    const skyDay = new THREE.Color(0x6ea8ff);
    const skyNight = new THREE.Color(0x0a1030);
    scene.background = skyNight.clone().lerp(skyDay, tod);
    sun.intensity = 0.2 + tod*0.9;
  }

  // コイン
  function placeCoins(n) {
    const mat = new THREE.MeshStandardMaterial({ color: 0xffd35a, metalness: 0.6, roughness: 0.2 });
    for (let i=0;i<n;i++) {
      let x=0,z=0,y=0;
      for (let t=0;t<50;t++) {
        const ang = Math.random()*Math.PI*2;
        const rad = THREE.MathUtils.randFloat(HALF*0.15, HALF*0.75);
        x = Math.cos(ang)*rad;
        z = Math.sin(ang)*rad;
        y = islandHeight(x,z);
        if (y>3) break;
      }
      const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,0.12,24), mat);
      coin.rotation.x = Math.PI/2;
      coin.position.set(x, y+0.9, z);
      scene.add(coin);
      coins.push(coin);
    }
  }
  placeCoins(18);

  function checkCoins(dt, t) {
    for (let i=coins.length-1;i>=0;i--) {
      const c = coins[i];
      c.rotation.z += dt*4; c.rotation.x += dt*0.5;
      if (c.userData.collected) continue;
      const d = c.position.distanceTo(player.position);
      if (d < 1.3) {
        c.userData.collected = true;
        const start = performance.now();
        const anim = () => {
          const k = Math.min(1, (performance.now()-start)/250);
          c.scale.setScalar(1 - k);
          c.position.y += 1.5* (1 - k) * 0.08;
          if (k < 1) requestAnimationFrame(anim); else { scene.remove(c); }
        };
        anim();
      }
    }
  }

  // 一人称用カメラ
  function updateCameraFirstPerson(){
    camera.position.copy(player.position);
    camera.position.y += HEAD_HEIGHT;
    const qYaw   = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), fpYaw);
    const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), fpPitch);
    camera.quaternion.copy(qYaw).multiply(qPitch);
  }

  // Resize
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Main loop
  let last = performance.now();
  function animate() {
    const now = performance.now();
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    updatePlayer(dt);
    updateHumanAnim(dt);
    checkCoins(dt, now*0.001);
    updateLighting(now*0.001);

    if (viewMode === 'first') {
      updateCameraFirstPerson();
    } else {
      controls.target.lerp(player.position, 1 - Math.exp(-8*dt));
      controls.update();
    }

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>小さな島デモ（ローカルOK版）</title>
<style>
  html, body { height: 100%; margin: 0; background: #0b1220; color: #e9ecff; font-family: system-ui, -apple-system, Segoe UI, Arial, "Noto Sans JP", sans-serif; }
  #ui { position: fixed; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
  .hud { display: flex; gap: 8px; padding: 10px; pointer-events: none; }
  .chip { background: rgba(20,25,46,.75); border: 1px solid rgba(88,225,255,.25); border-radius: 999px; padding: 6px 12px; font-variant-numeric: tabular-nums; box-shadow: 0 6px 18px rgba(0,0,0,.35); }
  .hint { margin-left: auto; opacity: .85; }
  #stickArea { position: fixed; left: 12px; bottom: 12px; width: 160px; height: 160px; pointer-events: auto; border-radius: 12px; background: rgba(20,25,46,.25); border: 1px dashed rgba(88,225,255,.25); touch-action: none; }
  #stickBase, #stick { position: absolute; border-radius: 50%; transform: translate(-50%,-50%); touch-action: none; }
  #stickBase { width: 110px; height: 110px; left: 80px; top: 80px; background: rgba(88,225,255,.08); border: 1px solid rgba(88,225,255,.35); }
  #stick { width: 56px; height: 56px; left: 80px; top: 80px; background: rgba(88,225,255,.35); border: 2px solid rgba(255,255,255,.6); }
  #jumpBtn { position: fixed; right: 18px; bottom: 18px; width: 70px; height: 70px; border-radius: 50%; background: rgba(88,225,255,.28); border: 2px solid rgba(255,255,255,.6); pointer-events: auto; touch-action: none; }
  #credits { text-align: center; font-size: 12px; opacity: .75; padding: 6px 0 10px; }
  #error { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; text-align: center; padding: 20px; background: #0b1220; }
  #error .box { background: #1a2036; border: 1px solid #334; padding: 16px; border-radius: 10px; }
  canvas { display: block; }
</style>
</head>
<body>
<div id="ui">
  <div class="hud">
    <div class="chip">🌞 <span id="timeOfDay">昼</span></div>
    <div class="chip">💰 <span id="coins">0</span> / <span id="totalCoins">0</span></div>
    <div class="chip hint">操作：ドラッグで視点、WASDで移動（モバイルは左下スティック）</div>
  </div>
  <div class="hud" style="justify-content:center;">
    <div id="credits">小さな島デモ：歩き回ってコインを集めよう</div>
  </div>
</div>
<div id="stickArea"><div id="stickBase"></div><div id="stick"></div></div>
<div id="jumpBtn"></div>
<div id="error"><div class="box">WebGLを初期化できませんでした。別のブラウザ（Chrome/Edge）で開くか、再読み込みしてください。</div></div>

<!-- Non-module scripts so file:// でも動く -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
(function () {
  if (!window.THREE || !document.createElement('canvas').getContext) {
    document.getElementById('error').style.display = 'flex';
    return;
  }

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x6ea8ff);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0, 30, 60);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.target.set(0, 10, 0);
  controls.maxPolarAngle = Math.PI * 0.49;

  const sun = new THREE.DirectionalLight(0xffffff, 1.0);
  sun.position.set(80, 120, 40);
  scene.add(sun);
  scene.add(new THREE.AmbientLight(0xffffff, 0.35));

  const ISLAND_SIZE = 400;
  const HALF = ISLAND_SIZE / 2;

  function hash(x, z) { return (Math.sin(x * 12.9898 + z * 78.233) * 43758.5453) % 1; }
  function valueNoise(x, z) {
    const xi = Math.floor(x), zi = Math.floor(z);
    const xf = x - xi, zf = z - zi;
    const h00 = hash(xi,zi), h10 = hash(xi+1,zi), h01 = hash(xi,zi+1), h11 = hash(xi+1,zi+1);
    const u = xf*xf*(3-2*xf), v = zf*zf*(3-2*zf);
    return THREE.MathUtils.lerp(THREE.MathUtils.lerp(h00,h10,u), THREE.MathUtils.lerp(h01,h11,u), v);
  }
  function fbm(x,z) {
    let a=0, amp=1, freq=0.05;
    for (let i=0;i<4;i++) { a += valueNoise(x*freq, z*freq)*amp; amp*=0.5; freq*=2.0; }
    return a;
  }
  function islandHeight(x, z) {
    const r = Math.sqrt(x*x + z*z);
    const mask = Math.max(0, 1 - Math.pow(r / HALF, 2));
    const base = mask*mask;
    const noise = fbm(x, z);
    const h = base * 22 + (noise-0.6) * 6 * base;
    return h;
  }

  const segs = 200;
  const geo = new THREE.PlaneGeometry(ISLAND_SIZE, ISLAND_SIZE, segs, segs);
  geo.rotateX(-Math.PI/2);
  const pos = geo.attributes.position;
  for (let i=0; i<pos.count; i++) {
    const x = pos.getX(i);
    const z = pos.getZ(i);
    pos.setY(i, islandHeight(x, z));
  }
  pos.needsUpdate = true;
  geo.computeVertexNormals();

  const terrainMat = new THREE.MeshStandardMaterial({ color: 0x8fbf7f, roughness: 0.95, metalness: 0.0 });
  const terrain = new THREE.Mesh(geo, terrainMat);
  terrain.receiveShadow = true;
  scene.add(terrain);

  const waterGeo = new THREE.CircleGeometry(HALF*1.15, 64);
  const waterMat = new THREE.MeshPhysicalMaterial({ color: 0x3aa9ff, roughness: 0.2, metalness: 0.0, transparent: true, opacity: 0.6 });
  const water = new THREE.Mesh(waterGeo, waterMat);
  water.rotation.x = -Math.PI/2;
  water.position.y = 0.0;
  scene.add(water);

  const trees = new THREE.Group();
  scene.add(trees);
  const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8a5a2b, roughness: 0.9 });
  const leafMat  = new THREE.MeshStandardMaterial({ color: 0x1f8a3b, roughness: 0.7 });

  function placeTrees(n) {
    n = n || 80;
    for (let i=0; i<n; i++) {
      const ang = Math.random()*Math.PI*2;
      const rad = Math.random()*HALF*0.8;
      const x = Math.cos(ang)*rad;
      const z = Math.sin(ang)*rad;
      const y = islandHeight(x,z);
      if (y < 2) { i--; continue; }
      const trunkH = THREE.MathUtils.randFloat(2.2, 3.2);
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, trunkH, 6), trunkMat);
      trunk.position.set(x, y + trunkH/2, z);
      const crownH = THREE.MathUtils.randFloat(2.8,3.6);
      const crownR = THREE.MathUtils.randFloat(1.2,1.7);
      const crown = new THREE.Mesh(new THREE.ConeGeometry(crownR, crownH, 8), leafMat);
      crown.position.set(x, y + trunkH + crownH*0.45, z);
      trees.add(trunk, crown);
    }
  }
  placeTrees();

  const coinMat = new THREE.MeshStandardMaterial({ color: 0xffd35a, metalness: 0.6, roughness: 0.2, emissive: 0x332200, emissiveIntensity: 0.25 });
  const coins = [];
  function placeCoins(n) {
    n = n || 18;
    for (let i=0;i<n;i++) {
      let x=0,z=0,y=0;
      for (let t=0;t<50;t++) {
        const ang = Math.random()*Math.PI*2;
        const rad = THREE.MathUtils.randFloat(HALF*0.15, HALF*0.75);
        x = Math.cos(ang)*rad;
        z = Math.sin(ang)*rad;
        y = islandHeight(x,z);
        if (y>3) break;
      }
      const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,0.12,24), coinMat);
      coin.rotation.x = Math.PI/2;
      coin.position.set(x, y+0.9, z);
      scene.add(coin);
      coins.push(coin);
    }
  }
  placeCoins(18);
  document.getElementById('totalCoins').textContent = coins.length;

  const player = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 12), new THREE.MeshStandardMaterial({ color: 0xdddddd }));
  player.castShadow = true;
  scene.add(player);
  player.position.set(0, islandHeight(0,0)+1.6, 0);

  controls.target.copy(player.position);
  camera.position.set(player.position.x+10, player.position.y+12, player.position.z+18);

  const keys = { w:0,a:0,s:0,d:0 };
  let vel = new THREE.Vector3();
  let onGround = false;

  function getGroundY(x,z){ return islandHeight(x,z); }

  function updatePlayer(dt) {
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0; forward.normalize();
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).negate();

    const input = new THREE.Vector3((keys.d - keys.a) + joyDir.x, 0, (keys.s - keys.w) + joyDir.y);
    if (input.lengthSq()>1e-6) input.normalize();

    const move = new THREE.Vector3();
    move.addScaledVector(forward, -input.z);
    move.addScaledVector(right, input.x);

    const speed = 10;
    vel.x = THREE.MathUtils.damp(vel.x, move.x*speed, 8, dt);
    vel.z = THREE.MathUtils.damp(vel.z, move.z*speed, 8, dt);

    const groundY = getGroundY(player.position.x, player.position.z) + 0.8;
    const gravity = -25;
    if (player.position.y <= groundY + 0.01) {
      player.position.y = groundY;
      vel.y = 0;
      onGround = true;
    } else {
      vel.y += gravity * dt;
      onGround = false;
    }

    if (jumpQueued && onGround) { vel.y = 9; jumpQueued = false; }

    player.position.addScaledVector(vel, dt);

    const r = Math.hypot(player.position.x, player.position.z);
    const maxR = HALF*1.1;
    if (r > maxR) {
      const s = maxR / r;
      player.position.x *= s;
      player.position.z *= s;
    }

    controls.target.lerp(player.position, 1 - Math.exp(-8*dt));
  }

  let collected = 0;
  const coinsEl = document.getElementById('coins');
  function checkCoins(dt, t) {
    for (let i=coins.length-1;i>=0;i--) {
      const c = coins[i];
      c.rotation.z += dt*4; c.rotation.x += dt*0.5;
      if (c.userData.collected) continue;
      const d = c.position.distanceTo(player.position);
      if (d < 1.3) {
        c.userData.collected = true;
        collected++;
        coinsEl.textContent = collected;
        const start = performance.now();
        const anim = () => {
          const k = Math.min(1, (performance.now()-start)/250);
          c.scale.setScalar(1 - k);
          c.position.y += 1.5* (1 - k) * 0.08;
          if (k < 1) requestAnimationFrame(anim); else { scene.remove(c); }
        };
        anim();
      }
    }
  }

  function updateLighting(t) {
    const tod = (Math.sin(t*0.02)*0.5 + 0.5);
    const skyDay = new THREE.Color(0x6ea8ff);
    const skyNight = new THREE.Color(0x0a1030);
    scene.background = skyNight.clone().lerp(skyDay, tod);
    sun.intensity = 0.2 + tod*0.9;
    document.getElementById('timeOfDay').textContent = tod>0.5 ? '昼' : '夜';
  }

  window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    if (e.key==='w' || e.key==='ArrowUp') keys.w=1;
    if (e.key==='a' || e.key==='ArrowLeft') keys.a=1;
    if (e.key==='s' || e.key==='ArrowDown') keys.s=1;
    if (e.key==='d' || e.key==='ArrowRight') keys.d=1;
    if (e.key===' ' && onGround) vel.y = 9;
  });
  window.addEventListener('keyup', (e) => {
    if (e.key==='w' || e.key==='ArrowUp') keys.w=0;
    if (e.key==='a' || e.key==='ArrowLeft') keys.a=0;
    if (e.key==='s' || e.key==='ArrowDown') keys.s=0;
    if (e.key==='d' || e.key==='ArrowRight') keys.d=0;
  });

  const stickArea = document.getElementById('stickArea');
  const stick = document.getElementById('stick');
  let joyActive = false, joyDir = {x:0, y:0};
  function setStick(x, y) { stick.style.left = x+'px'; stick.style.top = y+'px'; }
  function clampVec(v, max){ const l = Math.hypot(v.x, v.y); if (l>max){ v.x*=max/l; v.y*=max/l;} }
  stickArea.addEventListener('pointerdown', (e)=> {
    joyActive = true; stickArea.setPointerCapture(e.pointerId);
    const rect = stickArea.getBoundingClientRect(); const cx = e.clientX-rect.left, cy = e.clientY-rect.top;
    setStick(cx, cy);
    const v = {x: cx-80, y: cy-80}; clampVec(v, 50); joyDir.x = v.x/50; joyDir.y = v.y/50;
  });
  stickArea.addEventListener('pointermove', (e)=> {
    if (!joyActive) return;
    const rect = stickArea.getBoundingClientRect(); const cx = e.clientX-rect.left, cy = e.clientY-rect.top;
    const v = {x: cx-80, y: cy-80}; clampVec(v, 50); setStick(80+v.x, 80+v.y);
    joyDir.x = v.x/50; joyDir.y = v.y/50;
  });
  stickArea.addEventListener('pointerup', ()=> { joyActive=false; setStick(80,80); joyDir.x=0; joyDir.y=0; });

  const jumpBtn = document.getElementById('jumpBtn');
  let jumpQueued = false;
  jumpBtn.addEventListener('pointerdown', ()=> { jumpQueued = true; setTimeout(()=>jumpQueued=false, 180); });

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  let last = performance.now();
  function animate() {
    const now = performance.now();
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    updatePlayer(dt);
    checkCoins(dt, now*0.001);
    updateLighting(now*0.001);
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();
})();
</script>
</body>
</html>
